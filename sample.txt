COMMENT	// comment test
COMMENT_MACRO	//=desc: {아이고 힘들어라 2}
COMMENT_MACRO	//=end
ANNOTATION	@
TOKEN	Resource
PUBLIC	public
CLASS	class
TOKEN	JavaParser
LBRACE	{
COMMENT_MACRO	//=desc: {아이고 힘들어라}
COMMENT_MACRO	//=args: [
COMMENT	//   code: {코드}
COMMENT	// ]
COMMENT_MACRO	//=end
PRIVATE	private
VOID	void
TOKEN	parse
LPAR	(
TOKEN	String
TOKEN	code
RPAR	)
TOKEN	throws
TOKEN	FileNotFoundException
LBRACE	{
TOKEN	Iterator
LT	<
TOKEN	JavaToken
GT	>
TOKEN	it
SUBSTITUTE	=
TOKEN	Tokenizer
DOT	.
TOKEN	tokenize
LPAR	(
TOKEN	code
RPAR	)
DOT	.
TOKEN	iterator
LPAR	(
RPAR	)
SEMICOLON	;
TOKEN	try
LPAR	(
TOKEN	PrintWriter
TOKEN	pw
SUBSTITUTE	=
TOKEN	new
TOKEN	PrintWriter
LPAR	(
STRING	"./sample.txt"
RPAR	)
RPAR	)
LBRACE	{
TOKEN	while
LPAR	(
TOKEN	it
DOT	.
TOKEN	hasNext
LPAR	(
RPAR	)
RPAR	)
LBRACE	{
TOKEN	JavaToken
TOKEN	jt
SUBSTITUTE	=
TOKEN	it
DOT	.
TOKEN	next
LPAR	(
RPAR	)
SEMICOLON	;
TOKEN	JavaTokenEnum
TOKEN	jte
SUBSTITUTE	=
TOKEN	jt
DOT	.
TOKEN	getE
LPAR	(
RPAR	)
SEMICOLON	;
TOKEN	switch
LPAR	(
TOKEN	jte
RPAR	)
LBRACE	{
TOKEN	case
TOKEN	PACKAGE
COLON	:
TOKEN	String
TOKEN	fullPackageName
SUBSTITUTE	=
TOKEN	parsePackage
LPAR	(
TOKEN	it
RPAR	)
SEMICOLON	;
TOKEN	System
DOT	.
TOKEN	out
DOT	.
TOKEN	println
LPAR	(
STRING	"full package name: "
PLUS	+
TOKEN	fullPackageName
RPAR	)
SEMICOLON	;
TOKEN	break
SEMICOLON	;
TOKEN	case
TOKEN	IMPORT
COLON	:
TOKEN	Pair
LT	<
TOKEN	String
COMMA	,
TOKEN	String
GT	>
TOKEN	imp
SUBSTITUTE	=
TOKEN	importRelation
LPAR	(
TOKEN	it
RPAR	)
SEMICOLON	;
TOKEN	if
LPAR	(
TOKEN	imp
EQUAL	==
TOKEN	null
RPAR	)
TOKEN	continue
SEMICOLON	;
TOKEN	System
DOT	.
TOKEN	out
DOT	.
TOKEN	println
LPAR	(
STRING	"import package: "
PLUS	+
TOKEN	imp
DOT	.
TOKEN	getKey
LPAR	(
RPAR	)
PLUS	+
STRING	" -> "
PLUS	+
TOKEN	imp
DOT	.
TOKEN	getValue
LPAR	(
RPAR	)
RPAR	)
SEMICOLON	;
TOKEN	break
SEMICOLON	;
TOKEN	default
COLON	:
TOKEN	pw
DOT	.
TOKEN	write
LPAR	(
TOKEN	jt
DOT	.
TOKEN	getE
LPAR	(
RPAR	)
PLUS	+
STRING	"\t"
PLUS	+
TOKEN	jt
DOT	.
TOKEN	getValue
LPAR	(
RPAR	)
PLUS	+
STRING	"\n"
RPAR	)
SEMICOLON	;
TOKEN	break
SEMICOLON	;
RBRACE	}
RBRACE	}
RBRACE	}
RBRACE	}
PRIVATE	private
TOKEN	String
TOKEN	parsePackage
LPAR	(
TOKEN	Iterator
LT	<
TOKEN	JavaToken
GT	>
TOKEN	it
RPAR	)
LBRACE	{
TOKEN	StringBuilder
TOKEN	fsb
SUBSTITUTE	=
TOKEN	new
TOKEN	StringBuilder
LPAR	(
RPAR	)
SEMICOLON	;
TOKEN	while
LPAR	(
TOKEN	it
DOT	.
TOKEN	hasNext
LPAR	(
RPAR	)
RPAR	)
LBRACE	{
TOKEN	JavaToken
TOKEN	pkgToken
SUBSTITUTE	=
TOKEN	it
DOT	.
TOKEN	next
LPAR	(
RPAR	)
SEMICOLON	;
TOKEN	if
LPAR	(
TOKEN	pkgToken
DOT	.
TOKEN	getE
LPAR	(
RPAR	)
EQUAL	==
TOKEN	JavaTokenEnum
DOT	.
TOKEN	SEMICOLON
RPAR	)
LBRACE	{
TOKEN	return
TOKEN	fsb
DOT	.
TOKEN	toString
LPAR	(
RPAR	)
SEMICOLON	;
RBRACE	}
TOKEN	fsb
DOT	.
TOKEN	append
LPAR	(
TOKEN	pkgToken
DOT	.
TOKEN	getValue
LPAR	(
RPAR	)
RPAR	)
SEMICOLON	;
RBRACE	}
TOKEN	return
STRING	""
SEMICOLON	;
RBRACE	}
PRIVATE	private
TOKEN	Pair
LT	<
TOKEN	String
COMMA	,
TOKEN	String
GT	>
TOKEN	importRelation
LPAR	(
TOKEN	Iterator
LT	<
TOKEN	JavaToken
GT	>
TOKEN	it
RPAR	)
LBRACE	{
TOKEN	StringBuilder
TOKEN	fullImport
SUBSTITUTE	=
TOKEN	new
TOKEN	StringBuilder
LPAR	(
RPAR	)
SEMICOLON	;
TOKEN	while
LPAR	(
TOKEN	it
DOT	.
TOKEN	hasNext
LPAR	(
RPAR	)
RPAR	)
LBRACE	{
TOKEN	JavaToken
TOKEN	importCtx
SUBSTITUTE	=
TOKEN	it
DOT	.
TOKEN	next
LPAR	(
RPAR	)
SEMICOLON	;
TOKEN	if
LPAR	(
TOKEN	importCtx
DOT	.
TOKEN	getE
LPAR	(
RPAR	)
EQUAL	==
TOKEN	JavaTokenEnum
DOT	.
TOKEN	SEMICOLON
RPAR	)
LBRACE	{
TOKEN	String
TOKEN	ret
SUBSTITUTE	=
TOKEN	fullImport
DOT	.
TOKEN	toString
LPAR	(
RPAR	)
SEMICOLON	;
TOKEN	return
TOKEN	new
TOKEN	Pair
LT	<
GT	>
LPAR	(
TOKEN	ret
DOT	.
TOKEN	substring
LPAR	(
TOKEN	ret
DOT	.
TOKEN	lastIndexOf
LPAR	(
CHAR	'.'
RPAR	)
PLUS	+
TOKEN	1
RPAR	)
COMMA	,
TOKEN	ret
RPAR	)
SEMICOLON	;
RBRACE	}
TOKEN	fullImport
DOT	.
TOKEN	append
LPAR	(
TOKEN	importCtx
DOT	.
TOKEN	getValue
LPAR	(
RPAR	)
RPAR	)
SEMICOLON	;
RBRACE	}
TOKEN	return
TOKEN	null
SEMICOLON	;
RBRACE	}
PUBLIC	public
STATIC	static
VOID	void
TOKEN	main
LPAR	(
TOKEN	String
LBRACKET	[
RBRACKET	]
TOKEN	args
RPAR	)
TOKEN	throws
TOKEN	IOException
LBRACE	{
TOKEN	try
LPAR	(
TOKEN	FileInputStream
TOKEN	fis
SUBSTITUTE	=
TOKEN	new
TOKEN	FileInputStream
LPAR	(
STRING	"./src/main/java/com/kakao/search/middle/javalang/JavaParser.java"
RPAR	)
RPAR	)
LBRACE	{
TOKEN	byte
LBRACKET	[
RBRACKET	]
TOKEN	buf
SUBSTITUTE	=
TOKEN	new
TOKEN	byte
LBRACKET	[
TOKEN	4096
RBRACKET	]
SEMICOLON	;
TOKEN	StringBuilder
TOKEN	sb
SUBSTITUTE	=
TOKEN	new
TOKEN	StringBuilder
LPAR	(
RPAR	)
SEMICOLON	;
TOKEN	int
TOKEN	read
SEMICOLON	;
TOKEN	while
LPAR	(
LPAR	(
TOKEN	read
SUBSTITUTE	=
TOKEN	fis
DOT	.
TOKEN	read
LPAR	(
TOKEN	buf
RPAR	)
RPAR	)
GT	>
TOKEN	0
RPAR	)
LBRACE	{
TOKEN	String
TOKEN	s
SUBSTITUTE	=
TOKEN	new
TOKEN	String
LPAR	(
TOKEN	buf
COMMA	,
TOKEN	0
COMMA	,
TOKEN	read
RPAR	)
SEMICOLON	;
TOKEN	sb
DOT	.
TOKEN	append
LPAR	(
TOKEN	s
RPAR	)
SEMICOLON	;
RBRACE	}
TOKEN	String
TOKEN	code
SUBSTITUTE	=
TOKEN	sb
DOT	.
TOKEN	toString
LPAR	(
RPAR	)
SEMICOLON	;
TOKEN	new
TOKEN	JavaParser
LPAR	(
RPAR	)
DOT	.
TOKEN	parse
LPAR	(
TOKEN	code
RPAR	)
SEMICOLON	;
RBRACE	}
RBRACE	}
RBRACE	}
COMMENT	// comment is exist
